{
  "A": {
    "detail": "The Accumulator",
    "description": "8 bit accumulator used mostly for arithmetic, logical and data transfer operations.\r\nHolds a result of most of operations performed by ALU.\r\nThe Accumulator is bit and byte addressable.\r\nIt is located at 0E0h",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "B": {
    "detail": "B register",
    "description": "8 bit register used in conjunction with the Accumulator to multiply (MUL) or divide (DIV) value.\r\nWhile multiplying B stores one of the values to multiply, and after operation is completed, stores a higher byte of a result.\r\nWhile dividing B stores a divisor and after operation is done, stores a remainder of the result.\r\n\r\nIt is bit and byte addressable.\r\nIt\u0027s located at 0F0h.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "PSW": {
    "detail": "Program Status Word",
    "description": "8 bit register containing informations about current CPU state\r\n - CY / PSW.7: Carry flag - Set when the result of an addition exceeded 255, or when subtracting larger number from a smaller one.\r\n - AC / PSW.6: Auxiliary carry flag - Used for BCD operations. Set when ADD or SUBB operations result in carry/borrow between bit 3 and 4. Otherwise it is cleared.\r\n - F0 / PSW.5: General purpose flag - User can decide what is it used for\r\n - RS1 / PSW.4: Register bank selector bit 1\r\n - RS0 / PSW.3: Register bank selector bit 0\r\n - OV / PSW.2: Overflow flag - Set when a value of a signed addition or subtraction rolls over from -128 to 127 or the other way around.\r\n - PSW.1: User defined bit - User can decide what is it used for\r\n - P / PSW.0: Parity flag - Indicates odd or even number of set bits in accumulator. Updated on every cycle.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "@R0;@R1": {
    "detail": "Register",
    "description": "Helper register containing a memory address.\r\nUsed for indirect addressing.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "TCON": {
    "detail": "Time Control register",
    "description": "8 bit register used to control the two built in timers.\r\n\r\n| ***Bit***  | TCON.7 | TCON.6 | TCON.5 | TCON.4 | TCON.3 | TCON.2 | TCON.1 | TCON.0 |\r\n| ---------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |\r\n| ***Name*** | TF1    | TR1    | TF0    | TR0    | IE1    | IT1    | IE0    | IT0    |\r\n\r\n- TF0/TF1 - Timer Overflow - Set to 1 when timer has overflown (transition from all bits set to 1, to all bits set to 0). Cleared after running associated interrupt vector (Timer 0: 000Bh, Timer 1: 001Bh)\r\n\r\n- TR0/TR1 - Timer Run - Set to 1 when timer is running, set to 0 when timer is halted\r\n\r\n- IE0/IE1 - External interrupt - Set to 1 when transition from high to low signal is received on port 3.3, cleared after running associated vector (Timer 0: 0003h, Timer 1: 0013h)\r\n\r\n- IT0/IT1 - Exterial interrupt type - When set to 1 interrupts will be generated on transition from high to low signal on port 3.3, when set to 0 interrupt will be generated on low signal on port 3.3\r\n\r\n\r\n",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "R0;R1;R2;R3;R4;R5;R6;R7": {
    "detail": "Helper register",
    "description": "Helper register generally used as a temporary data storage.\r\nCan be used as one of operands in many operations.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": true,
    "prefix": "",
    "prefix_required": false
  },
  "DPTR": {
    "detail": "Data Pointer",
    "description": "User accessible, 16 bit register designed to store an address pointing to external memory.\r\nCan be accessed as two 8-bit registers, DPL (Data Pointer Low) and DPH (Data Pointer High)",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "PC": {
    "detail": "Program Counter",
    "description": "16 bit register storing address to the next instruction to be executed.\r\nThe program counter is incremented after each executed instruction, by the size of instruction that was executed.\r\nValue can be modified using Program Control instructions.\r\nAfter reset will set PC to 0h, which means that CPU will be expecting the first instruction to be at that address.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "SP": {
    "detail": "Stack Pointer",
    "description": "An 8 bit register containing an address to the top of the stack.\r\nWhile pushing data onto a stack, the SP is incremented **before** data is stored.\r\nWhile popping data from the stack, the SP is decremented **after** data is returned.\r\n\r\nInitial value of the stack pointer is 07h.\r\nValue can be modified by: PUSH, POP, ACALL, LCALL, RET, and, RETI",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "P0;P1;P2;P3": {
    "detail": "Port register",
    "description": "8 bit I/O register used to control an I/O port with the same name.\r\nEach bit correspods to a pin on the 8051 microcontroller.\r\nEach pin can be either as an input or output.\r\nTo change a pin mode you have to write data to it.\r\nIf you set a bit (write 1), pin will be configured as input, of you reset it (write 0) it will be configured as output.\r\nIt will also change voltage on that pin, setting a bit changes voltage to 5V, and resetting it changes it to 0V.\r\n\r\nAddresses of port registers:\r\n - P0: 80H\r\n - P1: 90H \r\n - P2: A0H\r\n - P3: B0H",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "TMOD": {
    "detail": "Timer Mode",
    "description": "8 bit register used to control the Operating Modes of built in timers.\r\nThe higher nibble is used to control T1 timer, and the lower nibble is used to control T0 timer.\r\n - Gate, bit 3 for T0 or 7 for T1: if 0 bits TR0/TR1 must be set. If 1 bits TR0/TR1 must be set and signal og INT0/INT1 must be high.\r\n - C/T, bit 2 for T0 or 6 for T1: if 0 (timer mode) timer counts pulses from the internal oscillator. If 1 (counter mode) counts pulses from pin T0/T1 (P3.4/P3.5)\r\n - T0M1/T1M1, bit 1 fot T0 or 5 for T1: timer operating mode select. Bit 1\r\n - T0M0/T1M0, bit 1 fot T0 or 5 for T1: timer operating mode select. Bit 0\r\n\r\n#### Operating modes:\r\n###### Mode 0 (T0M1/T1M1 = 0, T0M0/T1M0 = 0): 13 bit mode\r\nTimer 0 and Timer 1 operate as 8 bit counters.\r\nTimer register is configured as 13 bit register that consists of TH0/TH1 and lower 5 bits of TH0/TL1.\r\nThree most significant bits of TL0/TL1 should be ignored.\r\nSetting TR1 won\u0027t reset the Timer register.\r\nTimer interrupt (TF0/TF1) is set when the timer register rolls from the max value (1FFFh) to the min value (0h).\r\n\r\n###### Mode 1 (T0M1/T1M1 = 1, T0M0/T1M0 = 0): 16 bit mode\r\nSimilar to the mode 0, with the difference being that all bits from TH1 and TL1 are used.\r\nTimer interrupt (TF0/TF1) is set when the timer register rolls from the max value (0FFFFh) to the min value (0h).\r\n\r\n###### Mode 2 (T0M1/T1M1 = 0, T0M0/T1M0 = 1): 8 bit mode with auto reload\r\nTimer 0 and Timer 1 operate as 8 bit counters.\r\nTH0/TH1 holds a value that will be loaded to TL0/TL1 after an overflow.\r\nTimer interrupt (TF0/TF1) is set when the timer register rolls from the max value (0FFh) to the value set in TH0/TH1.\r\n\r\n###### Mode 3 (T0M1/T1M1 = 1, T0M0/T1M0 = 1): Split mode\r\nBoth timers are used at once, Timer 0 counting over TL0 and Timer 1 counting over TH0.\r\nTimer 1 can not be stopped independently of Timer 0, but it can be put in modes 0 to 2.\r\nTimer interrupt (TF0/TF1) is set when the timer register (TL0/TH0) rolls from the max value (0FFh) to the  min value (0h).\r\n\r\n\r\n",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "DPL": {
    "detail": "Data Pointer Low",
    "description": "",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": false,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  }
}