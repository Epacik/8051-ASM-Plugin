{
  "A": {
    "detail": "The Accumulator",
    "description": "8 bit accumulator used mostly for arithmetic, logical and data transfer operations.\r\nHolds a result of most of operations performed by ALU",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "B": {
    "detail": "B register",
    "description": "8 bit register used in conjunction with the Accumulator to multiply (MUL) or divide (DIV) value.\r\nWhile multiplying B stores one of the values to multiply, and after operation is completed, stores a higher byte of a result.\r\nWhile dividing B stores a divisor and after operation is done, stores a remainder of the result.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "PSW": {
    "detail": "Program Status Word",
    "description": "8 bit register containing informations about current CPU state\r\n - CY / PSW.7: Carry flag - Set when the result of an addition exceeded 255, or when subtracting larger number from a smaller one.\r\n - AC / PSW.6: Auxiliary carry flag - Used for BCD operations. Set when ADD or SUBB operations result in carry/borrow between bit 3 and 4. Otherwise it is cleared.\r\n - F0 / PSW.5: General purpose flag - User can decide what is it used for\r\n - RS1 / PSW.4: Register bank selector bit 1\r\n - RS0 / PSW.3: Register bank selector bit 0\r\n - OV / PSW.2: Overflow flag - Set when a value of a signed addition or subtraction rolls over from -128 to 127 or the other way around.\r\n - PSW.1: User defined bit - User can decide what is it used for\r\n - P / PSW.0: Parity flag - Indicates odd or even number of set bits in accumulator. Updated on every cycle.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "@R0;@R1": {
    "detail": "Register",
    "description": "Helper register containing a memory address.\r\nUsed for indirect addressing.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "TCON": {
    "detail": "Time Control register",
    "description": "8 bit register used to control the two built in timers.\r\n\r\n| ***Bit***  | TCON.7 | TCON.6 | TCON.5 | TCON.4 | TCON.3 | TCON.2 | TCON.1 | TCON.0 |\r\n| ---------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |\r\n| ***Name*** | TF1    | TR1    | TF0    | TR0    | IE1    | IT1    | IE0    | IT0    |\r\n\r\n- TF0/TF1 - Timer Overflow - Set to 1 when timer has overflown (transition from all bits set to 1, to all bits set to 0). Cleared after running associated interrupt vector (Timer 0: 000Bh, Timer 1: 001Bh)\r\n\r\n- TR0/TR1 - Timer Run - Set to 1 when timer is running, set to 0 when timer is halted\r\n\r\n- IE0/IE1 - External interrupt - Set to 1 when transition from high to low signal is received on port 3.3, cleared after running associated vector (Timer 0: 0003h, Timer 1: 0013h)\r\n\r\n- IT0/IT1 - Exterial interrupt type - When set to 1 interrupts will be generated on transition from high to low signal on port 3.3, when set to 0 interrupt will be generated on low signal on port 3.3\r\n\r\n\r\n",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "R0;R1;R2;R3;R4;R5;R6;R7": {
    "detail": "Helper register",
    "description": "Helper register generally used as a temporary data storage.\r\nCan be used as one of operands in many operations.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": true,
    "prefix": "",
    "prefix_required": false
  },
  "DPTR": {
    "detail": "Data Pointer",
    "description": "User accessible, 16 bit register designed to store an address pointing to external memory\r\n",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "PC": {
    "detail": "Program Counter",
    "description": "16 bit register storing address to the next instruction to be executed.\r\nThe program counter is incremented after each executed instruction, by the size of instruction that was executed.\r\nValue can be modified using Program Control instructions.\r\nAfter reset will set PC to 0h, which means that CPU will be expecting the first instruction to be at that address.",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  },
  "SP": {
    "detail": "Stack Pointer",
    "description": "An 8 bit register containing an address to the top of the stack.\r\nWhile pushing data onto a stack, the SP is incremented **before** data is stored.\r\nWhile popping data from the stack, the SP is decremented **after** data is returned.\r\n\r\nInitial value of the stack pointer is 07h.\r\nValue can be modified by: PUSH, POP, ACALL, LCALL, RET, and, RETI",
    "valid_operands": [],
    "affected_flags": [],
    "dont_generate_syntax": true,
    "dont_duplicate_in_all_docs": false,
    "prefix": "",
    "prefix_required": false
  }
}